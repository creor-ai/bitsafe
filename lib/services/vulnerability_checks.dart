import '../models/transaction.dart';
import '../models/address_details.dart';
import 'dart:typed_data';
import 'package:crypto/crypto.dart';

class VulnerabilityChecks {
  // Check for address reuse
  static BigInt n = BigInt.parse('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141', radix: 16);

  static void checkAddressReuse(List<Transaction> transactions, AddressDetails details) {
    var seenAddresses = <String>{};
    bool hasReuse = false;

    for (var transaction in transactions) {
      for (var input in transaction.inputs) {
        if (!seenAddresses.add(input.address) && input.address == details.address) {
          hasReuse = true;
          break; // Break from the inner loop
        } else {
          seenAddresses.add(input.address); // Ensure to add address if not added before
        }
      }
      if (hasReuse) break; // Exit early if reuse is detected in inputs

      for (var output in transaction.outputs) {
        if (!seenAddresses.add(output.address) && output.address == details.address) {
          hasReuse = true;
          break; // Break from the inner loop
        } else {
          seenAddresses.add(output.address); // Ensure to add address if not added before
        }
      }
      if (hasReuse) break; // Exit early if reuse is detected in outputs
    }

    details.updateAddressReuse(hasReuse);
  }

  static void checkNonceReuse(List<Transaction> transactions, AddressDetails details) {
    Map<BigInt, List<BigInt>> sigs = {};
    bool hasReuse = false;

    for (var tx in transactions) {
      for (int vinIndex = 0; vinIndex < tx.inputs.length; vinIndex++) {
        var vin = tx.inputs[vinIndex];
        if (vin.sigScript.isNotEmpty && vin.sigScript.length >= 142) {
          BigInt r = BigInt.parse(vin.sigScript.substring(10, 74), radix: 16);
          BigInt s = BigInt.parse(vin.sigScript.substring(77, 141), radix: 16);
          Uint8List txHash = serializeTxForSignature(tx, vinIndex, vin.prevoutScript);
          BigInt z = BigInt.parse(sha256.convert(txHash).toString(), radix: 16);

          if (sigs.containsKey(r)) {
            hasReuse = true;
            details.updateNonceReuse(true);
            break; // Break out of the inner loop only
          } else {
            sigs[r] = [s, z];
          }
        }
      }
      if (hasReuse) break; // Break out of the outer loop if reuse detected
    }

    if (!hasReuse) {
      details.updateNonceReuse(false); // Update with false if no reuse detected
    }
  }

  static Uint8List serializeTxForSignature(Transaction tx, int inputIndex, String script) {
    // Your implementation of transaction serialization for signature goes here
    return Uint8List.fromList([]); // Placeholder
  }

  static BigInt invMod(BigInt a, BigInt m) {
    BigInt m0 = m, y = BigInt.zero, x = BigInt.one;

    if (m == BigInt.one) return BigInt.zero;

    while (a > BigInt.one) {
      BigInt q = a ~/ m;
      m = a % m;
      a = m;
      m = y;
      y = x - q * y;
      x = m;
    }

    if (x < BigInt.zero) {
      x += m0;
    }

    return x;
  }

  // Check for dust transactions
  static void checkDustTransactions(List<Transaction> transactions, AddressDetails details) {
    bool hasDustTransactions = transactions.any((transaction) => transaction.outputs.any((output) => output.address == details.address && output.amount < 0.00001));

    details.updateDustTransactions(hasDustTransactions);
  }

  // Check for unusual patterns (e.g., high transaction volumes)
  static void checkUnusualPatterns(List<Transaction> transactions, AddressDetails details) {
    bool hasUnusualPatterns = transactions.any((transaction) => transaction.outputs.any((output) => output.amount > 10 // Arbitrary amount for unusual high output
        ));

    details.updateUnusualPatterns(hasUnusualPatterns);
  }

  // A method to run all checks
  static void runAllChecks(List<Transaction> transactions, AddressDetails details, List<String> knownBadAddresses) {
    checkAddressReuse(transactions, details);
    checkDustTransactions(transactions, details);
    checkUnusualPatterns(transactions, details);
    // Add any additional checks as necessary
  }
}
